#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only
# --completion-helper <full-input-string>
# COMP_LINE COMP_CWORD COMP_WORDS env variables are required.
# intended COMPREPLY returned as stdout text

function SourceConsoleCompletionHelper(){

	set -e

	: "${COMP_LINE:?⛔ ERROR: --completion-helper: COMP_LINE env variable is empty: $@}"
	: "${COMP_CWORD:?⛔ ERROR: --completion-helper: COMP_CWORD env variable is empty: $@}"
	: "${COMP_WORDS:?⛔ ERROR: --completion-helper: COMP_WORDS env variable is empty: $@}"

	: "${1:?⛔ ERROR: --completion-helper: full-input-string argument is empty: $@}"

	local compPrompt="$1" ; shift

	[ "${COMP_WORDS[0]}" == "Source" ] || {
		echo "⛔ ERROR: --completion-helper: must be called to complete 'Source' command: $@, ${COMP_WORDS[0]}" >&2
		set +e ; return 1
	}
	[ "$COMP_LINE" == "$compPrompt" ] || {
		echo "⛔ ERROR: --completion-helper: full-input-string != \$COMP_LINE: $@" >&2
		set +e ; return 1
	}

	local list

	# grab the vertical list
	list=$(
		Distro --completion-all \
		| grep '^\(DistroSource\|Source\|Build\|Clean\|List\).*.fn.sh$' \
		| sort -u \
		| sed 's:\.fn\.sh$::' 
	)

	# 2nd token? complete the subcommands…
	if [ "$COMP_CWORD" -eq 1 ]; then
		# COMPREPLY=( $( compgen -W "$list" -- "$cur" ) )
		printf '%b' \
			"$( compgen -W "$list" -- "$cur" )"

		return 0
	fi

	# 3rd-token TAB right after a valid subcommand?
	if [ "$COMP_CWORD" -eq 2 ] && [ -z "$cur" ] ; then

		: # COMPREPLY=()    # eat the TAB, no suggestions

		# grep -F = fixed string; -x = whole line; -q = quiet
		if printf '%s\n' "$list" \
			| grep -Fxq -- "$sub" \
		; then
			# clear out all COMP_* so no accidental recursion
			(
				COMP_CWORD= COMP_WORDS=

				echo >&2
				Source "$sub" --help 1>&2 || true
				echo >&2

				# redraw prompt + the unfinished line
				. "$MDLT_ORIGIN/myx/myx.distro-.local/sh-lib/LocalTools.EchoBashPrompt.include"
				DistroLocalEchoBashPrompt "$COMP_LINE" >&2
			)
			return 0
		fi

		return 0
	fi

	# 3) otherwise fall through to your manual default+filenames
	set +e ; return 1
}
